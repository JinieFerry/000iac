listen이 아니라 WATCH , 실제로 서비스를 하는 건 Pod 

프록시는 내부 서버 밖에서 대표

k8s가 안깔린 것은 노드라고 불리지 않음     

서버는 vm을 노드라고 보기 때문에, vm이 몇개인지에 따라 노드라고부름   

같거나 비슷한 일을 하는 다른 노드의 아이피를 알아야 하기 때문에 그것을 k-proxy가 모아둠. 고객들은 k-proxy로 접속하기 때문에 또 서버와 연결해줘야 함  

노드에는 대표하는 큐블렛이 있고, 유저들이 접속하는 접점이 큐브 프록시    

ansible yaml에서는 다 보내기만 하지 어떻게 죽었는지 알 수가 없음 (성공 여부 정도만 나옴): 죽기 직전까지 예측할 수 없음=대비 불가, 카피,데몬,엔진 올리기 정도의 명령 외에는 선언 뿐    

그래서 정보를 계속 보내게 하고 큐블렛이 자기 노드 상태를 api에게 계속 보고 하면, 그 상태를 etcd에게 저장함   

그러면 명령을 내릴 사람 컨트롤 할 사람이 필요함: 죽은 애 있는지, 살릴 애 있는 지 = 변한 것 있어?   

#### Scheduled :보고 있다가 쓸 수 있는 것과 아닌 것을 분류 해 뒀다가 배정함. 하지만 확정하지 않음  
a였으면 좋겠어, 근데 안되면 b도 괜찮아   

우리 yaml 파일도 모두 etcd에 저장되어 있음.    

ai는 연산하는 일을 함: 같은 노드에 다른 회사 노드도 있음. 하드,메모리 인터페이스 등등 많음, ai는 연산만 하면 되면 cpu연산 전용 노드로 아키텍처에 넣으면 됨. 스토리지가 아주 좋은 성능을 가진 것을 넣어야 함: 여기엔 웹 파드 들어오지마 하고 디테일하게 정할 수 있음      
나는 사실 앱서버야~ 앱이 많고, 주문과 장바구니도 많아 그래서 이게 있는 파드에 같이 놔줘: 떨어져 있으면 그만큼 통신망이 또 차지하기 때문에 <> 난 얘랑 같이 있으면 싫어~하는 경우도 있음    

#### IP는 계속 바뀜: 코딩 할 때 아이피를 아예 줘버리면 통신 할 수가 없음     
프론트에 루트 서비스하는 애 아무나 받아: 서비스 네임으로 통신한다

### 크게 명령어가 3개 있음:
#### kubectl:시스템 관리자가 씀:대부분의 명령(나머지 모든 명령)  
#### kubeadm:초기에 설정하고 확인할 때 씀(루트가 하는 일), " manifests는 yaml 파일(명세서)이다."   
'명세서'=yaml파일에 명세서 작성하니까 ㅎㅎ      
#### kubelet: 각 노드의 컨테이너에 해당하는 것   
docker가 하던 contrainerd를 container runtime이 함(빌드를 못 함):nerdctl이 빌들르 함(파드 안에 넣을 지 말 지로 고민 많음)    

:빌드 해서 보내면 회선료가 엄청 많이 나옴:개발 서버를 어디에 두냐에 따라서(금융권은 무조건 회사 내부 서버에서 해야함 빌드를 해서 보내거나, 양쪽에 빌더를 두면 어떨지 아키텍처를 해야 함)   프로그래밍 하는 데 빌드해서 다른 노드에 보내면 그것도 오래 걸림.    

큰 프로그램도 msa로 나눴으면 파드 안에서 빌드하는 것도 괜찮음 = 사업 내용에 따라서 아키텍처에서 빌더를 어디에 둘지를 정하는 것에 따라서 회선료가 달라짐   

#### 클러스터의 개념이 확장이 되었음. 
: 네트워크에서는 같은 거 묶어 둔게 클러스터라고 확정 -> 지금은 다 클라우드를 사용하니까 남는 곳에 평소에는 같이 묶어두자  

#### 선언적이다 키:값 = 명령하지 않는다   
채팅 서버는 중국에서 공격이 많음. 뻗어도 좋으니까 줄이라고도 함.   

배포하는 역과 복사하는 역이 필요함 늘리려면   

결국에는 노드해서 늘리는 일만 했으니까 서비스들이 파드해야 함 : Service 라는 이름으로 나눔 (백/프론트/웹/앱/DB서버)=yaml파일에 써 둠.    

config web : 환경 정보를 변수로 해서 따로 저장하는 것  ex. ip를 박아버리면 yaml을 쓸 수가 없음(아이피는 계속 바뀌고, 그때 마다 바꿔 줄 수가 없어서 ) = 변수는 yaml파일에 박아두지 말고, 환경변수들을 모아둔 것을 따로 모아서 yaml을 따로 만들어라(앤서블 연습할 때 vars로 연습해 봄), 그 중에서 키 값은 또 따로 모았음 그게 Secret   

PVC: Persispect Volume Claime(요청해야 하니까)영구저장 볼륨   
파드마다 볼륨을 배정해 줘야 함   스토리지팜이 있는 것 :k8s없으니까 노드라고 안 부름    
고객이 왔다갔다한 정보도 다 저장하는 것    

스토리지를 서비스 하는 클라우드에다가 할 수도 있다. : 스토리지가 비싸기 때문에  아키텍처 할 때 트래픽이 크면 스토리지에 두면 트래픽 요금이 더 들 수 있음 : 잘 꺼내 쓰지 않는 것을 두는 게 좋음   

따라서 시스템 매니저가 사업 로직을 잘 알아야 함.:트래픽이 어디서 발생하는지를 알아야 함. DB엔지니어들 하고도 친해야 함. 사실은 DB가 서비스 보다도 더 중요함.: DB엔지니어한테 고집 부리면 안 됨    

주고 받을 일이 있을 때 NameSpace 씀   HPA를 많이 함 이제는 수직 스케일링 잘 안 함  
파드를 늘려야겠다하면 Deployment(:배포)한테 요청 -> Replicaset이 복사   

전체 개요 자체 하나도 클러스터가 됨


모든 통신은 api가 중개한다.    
모든 환경들을 etcd에 저장한다.(통신 내역 포함 모든 정보를 저장한 db)    
컨트롤 매니저가 컨트롤 함(클라우드 붙었을 때만 써서 c-c-m)   : 바쁘니까 미리 스케줄 잡아둠   
자기와 친구들 네트워크 정보랑 내 상태를 저장하고 알리는 애가 필요해서 네트워크에서는 노드 마다 큐블렛이 하나씩 있다.    
큐블렛은 각 노드 마다 os로 띄움(os의 데몬으로 띄워버림:그래야 빠르기 때문에, 고정된 것이니까)    
