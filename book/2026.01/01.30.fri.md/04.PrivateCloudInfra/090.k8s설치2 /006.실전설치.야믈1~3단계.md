네, 현재 테라폼이 없는 환경이라면 **Ansible(앤서블)**을 사용하여 1단계(OS 최적화)부터 3단계(K8s 도구 설치)까지를 하나의 **YAML 플레이북**으로 묶어 실행하는 것이 가장 완벽한 실무형 IaC 방식입니다.

강사님의 마스터 PC에서 수강생 PC(예비 서버)들을 대상으로 한 번에 설정을 밀어 넣는 시나리오로 구성해 드리겠습니다.

---
005.실무에서 iac설치.md에서의 1,2,3단계를 yaml로 만드는 것   

변수값 들을 키와 값의 대칭으로 따로 대칭으로 저장하고 불러올 수 있음, 누구한테 할건지, 무슨 일을 할 것인지 크게 3가지 함. 마크업 랭귀지 정의하는 것이 yaml. (버전을 넣어주지는 않음)       
엔서블은 대상과 일을 정의      

### 커맨드와 쉘의 차이
커맨드: 바이너리= 하나의 일만: 옵션만 있고 변수를 받아 올 수는 없음: 단순 명령일 때          
쉘: 명령어로 한 줄 짜리 프로그램화 할 수 있음 + 환경 변수를 쓸 수 있음: 이어질 때     

## 0. k8s_install 디렉토리 하나 따로 만들기
```
cd k8s_install/
vi hosts.ini
```
## 1. Ansible을 이용한 OS 및 K8s 환경 준비 (1~3단계 통합)

이 YAML 파일은 각 서버에 접속하여 스왑 해제, 커널 설정, 컨테이너 런타임 및 K8s 도구 설치를 자동으로 수행합니다.

### [설계] k8s_setup_playbook.yaml 생성

```
#디렉토리로 이동
cd k8s_install
#yaml 파일 만들기 아래 긴 코드 복붙
vi k8s_setup_playbook.yaml
```
##### k8s_setup_playbook.yaml 파일에 붙여넣을 코드

```yaml
---
- name: Kubernetes OS 및 환경 최적화 (1~3단계)
  hosts: all
  become: yes
  tasks:
    # 1단계: OS 설정
    # 무슨 일을 하는지 다음 사람이 알 수 있도록 네임에 써 둠 (꼭 안 쳐도 되고 수정만 해도 됨) 
    - name: 스왑(Swap) 메모리 비활성화
      shell: |
        swapoff -a
        sed -i '/swap/s/^/#/' /etc/fstab
    #05.실i설에서의 1단계 os환경 최적화 역할
    - name: 커널 모듈 로드 설정
      # 컨첸츠를 카피해옴
      copy:
        #카피 해 올 위치
        dest: /etc/modules-load.d/k8s.conf  
        content: |
          overlay
          br_netfilter

    - name: 커널 모듈 즉시 로드
      modprobe:
        name: "{{ item }}"
        #로드 한 상태 유지: 안됐으면 하고, 됐으면 넘어가~
        state: present
      loop:
        - overlay
        - br_netfilter

    - name: 커널 파라미터(sysctl) 설정
      # 메뉴얼에 나와있음 (linux 사이트)
      sysctl:
        name: "{{ item.name }}"
        value: "{{ item.value }}"
        state: present
        sysctl_file: /etc/sysctl.d/k8s.con
      #yaml은 리스트로 키와값이 있음. 리스트 하나 더 추가 한 것, 리스트는 한 줄 씩 실행함
      #콤마를 통해서 딕셔너리 형태로 두 가지 값:name과 value 사용
      loop:
        - { name: 'net.bridge.bridge-nf-call-iptables', value: '1' }
        - { name: 'net.bridge.bridge-nf-call-ip6tables', value: '1' }
        - { name: 'net.ipv4.ip_forward', value: '1' }

    # 2단계: 컨테이너 런타임(Containerd) 설치
    - name: Containerd 설치 및 설정
    # 모듈 들은 처리 할 것을 두 칸 씩 들여서 씀 (네 칸도 가능하지만 가시성 떨어짐)
      apt:
        name: containerd
        state: present
        update_cache: yes

    - name: Containerd 기본 설정 생성 및 SystemdCgroup 활성화
      # 05.실i설의 2단계 컨테이너 런타임 shell 명령어를 sudo 빼고 그대로 친 것과 같음
      shell: |
        mkdir -p /etc/containerd
        containerd config default > /etc/containerd/config.toml
        sed -i 's/SystemdCgroup = false/SystemdCgroup = true/g' /etc/containerd/config.toml
      #재적용 할 때 아래의 handlers랑 연결 됨
      notify: restart containerd

    # 3단계: K8s 도구(v1.30.14) 설치
    - name: K8s 공식 레포지토리 키 및 소스 리스트 추가
      shell: |
        # curl:다운로드 시스템 관리 시 자주 쓰는 명령어
        # 우분투에서는 /를 두개 씀 (옵션과 헷갈리지 않기 위해서), f:fail
        # curl -? 명령어를 통해서 curl 명령어에 대해서 설명 볼 수 있음, s:silent 로그 뽑지 마라
        curl -fsSL https://pkgs.k8s.io/core:/stable:/v1.30/deb/Release.key | sudo gpg --dearmor -o /etc/apt/keyrings/kubernetes-apt-keyring.gpg
        echo 'deb [signed-by=/etc/apt/keyrings/kubernetes-apt-keyring.gpg] https://pkgs.k8s.io/core:/stable:/v1.30/deb/ /' | sudo tee /etc/apt/sources.list.d/kubernetes.list

    - name: K8s v1.30.14 도구 설치
      apt:
        name:
          - kubelet=1.30.14-1.1
          - kubeadm=1.30.14-1.1
          - kubectl=1.30.14-1.1
        state: present
        update_cache: yes

    - name: 버전 업데이트 고정
      dpkg_selections:
        name: "{{ item }}"
        selection: hold
      loop: [kubelet, kubeadm, kubectl]
  # 위의 notihy가 재적용 될 때
  handlers:
    - name: restart containerd
      service:
        name: containerd
        state: restarted

```
저장하고 나오기 `wq!`

---


## 2. 실행 방법

마스터 PC(또는 강사님 PC)에서 앤서블을 통해 대상 서버들에게 명령을 내립니다.

### ① 인벤토리(hosts) 파일 작성

대상 서버들의 IP를 지정합니다.

```bash
# hosts.ini 파일 생성 : 자기 아이피 넣기
[k8s_nodes]
192.168.115.251  # 마스터 후보
192.168.115.1  # 워커 후보
192.168.115.2  # 워커 후보

```

결과확인
```
master@vmmaster1:~$ cd k8s_install
master@vmmaster1:~/k8s_install$ ls
master@vmmaster1:~/k8s_install$ vi hosts.ini
master@vmmaster1:~/k8s_install$ vi hosts.ini
master@vmmaster1:~/k8s_install$ cat hosts.ini 
[k8s_nodes]
192.168.115.251  # 마스터 후보
#192.168.115.1  # 워커 후보 일단 막아두기
#192.168.115.2  # 워커 후보 일단 막아두기
```
ssh되는 디렉토리끼리 파일 통째로 보내기
```
scp -r ./k8s_install master@192.168.115.1:/home/master/
```
---
### ② 플레이북 실행

```bash

# 앤서블 실행 명령어
#ansible-playbook -i hosts.ini k8s_setup_playbook.yaml -u <사용자계정> --become-password-confirm
#--become-password-confirm 에러나서 코드 수정
ansible-playbook -i hosts.ini k8s_setup_playbook.yaml -u master --ask-become-pass
#비컴패스워드 : 1234

# 안되면 -K옵션
에러나서 curl 말고 url 쓰기로 수정
<img width="1930" height="1035" alt="image" src="https://github.com/user-attachments/assets/e28bc1d9-6772-41d4-b676-7f1637717c81" />
```
https://github.com/putto4u/04.PrivateCloudInfra/blob/main/090.k8s%EC%84%A4%EC%B9%982/005.%EC%8B%A4%EB%AC%B4%EC%97%90%EC%84%9C%20iac%EC%84%A4%EC%B9%98.md   

3단계 까지가 나머지 노드도 하는 일 :vmmaster1,vm1,vm2공통
## 3. 실행 후 단계 (4단계~5단계)
위의 앤서블 작업이 끝나면 모든 서버는 `kubeadm` 명령어를 실행할 준비가 완료된 상태.   
이후부터는 **마스터 노드에서만** 직접 `kubeadm init --config kubeadm-init.yaml`을 실행:4단계는 vmmaster1만
------
04.PrivateCloudInfra/090.k8s설치2/005.실무에서 iac설치.md
4단계 v1beta4 기반 설계도 작성 실행 : 마스터 노드만 하는 일 :vmmaster1만 하는 일    
```
kubeadm config print init-defaults --com:ㅂㅁponent-configs KubeletConfiguration > kubeadm-init.yaml
# vi kubeadm-init.yaml 실행하여 아래 핵심 내용 수정
# 1. advertiseAddress: 마스터IP 192.168.115.
# 2. kubernetesVersion: 1.30.14 # kubectl version으로 버전 확인해서 맞춰서 수정
# 3. podSubnet: 10.244.0.0/16  #pod 내의 서브넷이라 가상으로 매겨져서 파일에서 보이지 않음
# 4. cgroupDriver: systemd (KubeletConfiguration 섹션)

```
<img width="926" height="865" alt="image" src="https://github.com/user-attachments/assets/41683a7b-ef24-4d2e-a866-524fddb1454c" />
------
5단계: 마스터 노드 가동 및 관리 권한 부여 (마스터 노드)  한번만 실행
```
# 선언형 구축 실행
# init으로 초기화: ip대역, 컨트롤 패널들, 서브넷들이 해야 하는 일들이 들어있는 yaml파일을 실행시킴
# 실행 후 자동으로 conf 파일이 만들어짐 
sudo kubeadm init --config kubeadm-init.yaml

# 관리자(kubectl) 권한 설정 (이 작업이 빠지면 kubectl 명령이 작동하지 않음)
mkdir -p $HOME/.kube #.kube는 ls로는 보이지 않아서 ls -al로 봐야 함

sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config 
sudo chown $(id -u):$(id -g) $HOME/.kube/config  #sudo는 root권한이니까 오너와 그룹의 권한을 master로 바꾸는 명령
```
6단계: 파드 네트워크(CNI) 배포 (마스터 노드)
노드 상태를 Ready로 만들고 파드 간 통신을 활성화합니다.
```
cd /k8s_install
nano hosts.ini # 마스터와 워커 후보 3개 다 모두 열어두기

# 우리 아이피 대역은 Flannel 사용할 것이니까 Flannel 
# 최신 버전의 Flannel manifest 적용
kubectl apply -f https://github.com/flannel-io/flannel/releases/latest/download/kube-flannel.yml

# Calico CNI 설치 (실무 표준 중 하나)
# kubectl apply -f https://raw.githubusercontent.com/projectcalico/calico/v3.28.0/manifests/calico.yaml
```
6-2 확인:
```
#노드상태 확인 : vmmaster1: Ready 
kubectl get nodes -o wide

#플라넬/시스템 파드 확인
kubectl get pods -A -o wide


```
7단계: 워커 노드 조인 및 상태 확인
```
# 워커 노드에서 마스터가 발행한 조인 토큰 실행
sudo kubeadm join 192.168.1.10:6443 --token ...

# 마스터에서 노드 상태 최종 확인
kubectl get nodes
```
